Ce quâ€™on a construit (vue dâ€™ensemble)
ğŸ¯ Objectif du projet CESI

Mettre en place une application logicielle complÃ¨te, avec :

dÃ©veloppement

qualitÃ©

sÃ©curitÃ©

CI/CD

dÃ©ploiement

orchestration

ğŸ‘‰ Pas juste du code, mais un systÃ¨me industriel.

ğŸ§± Architecture finale
[ Frontend React ]
        |
        v
[ Backend Spring Boot ]
        |
        v
[ PostgreSQL ]


Le tout :

packagÃ© avec Docker

dÃ©ployable en local (Docker Compose)

dÃ©ployÃ© sur Kubernetes (Minikube)

testÃ© en CI (GitHub Actions)

2ï¸âƒ£ Tout ce quâ€™on a installÃ© (et pourquoi)
ğŸ–¥ï¸ Outils systÃ¨me
âœ” Java 17 (Eclipse Adoptium)

pour exÃ©cuter Spring Boot

Java = langage backend

ğŸ‘‰ Pourquoi Java 17 ?
Version LTS, stable, recommandÃ©e en entreprise.

âœ” Maven

outil de build Java

tÃ©lÃ©charge les dÃ©pendances

compile

lance les tests

gÃ©nÃ¨re le JAR

ğŸ‘‰ Sans Maven, impossible de faire du Spring Boot proprement.

âœ” Node.js + npm

nÃ©cessaire pour React

build du frontend

ğŸ‘‰ React = frontend moderne demandÃ© implicitement.

âœ” Docker Desktop

moteur de containers

permet :

Docker Compose

Docker build

Minikube (driver docker)

ğŸ‘‰ Docker = fondation du projet.

âœ” Minikube

Kubernetes local

dÃ©monstration de CD

orchestration rÃ©elle

ğŸ‘‰ Pas du cloud, mais mÃªme logique que production.

3ï¸âƒ£ Ce quâ€™on a dÃ©veloppÃ© (code)
ğŸ§© Backend â€“ Spring Boot

API REST

JPA (ORM) pour la DB

Flyway pour les migrations

Spring Security (auth basique)

Pourquoi JPA ?

mappe les classes Java â†” tables SQL

Ã©vite le SQL manuel

standard entreprise

Pourquoi Flyway ?

versionner la base de donnÃ©es

rejouer les migrations automatiquement

cohÃ©rence entre environnements

Pourquoi Spring Security ?

sÃ©curitÃ© = exigence CESI

protection des endpoints

auth basique suffisante pour dÃ©mo

ğŸ–¥ï¸ Frontend â€“ React

interface utilisateur

appels API vers backend

servi via Nginx en prod (container)

ğŸ‘‰ React buildÃ© â†’ fichiers statiques â†’ Nginx â†’ navigateur

4ï¸âƒ£ Docker : ce quâ€™on a VRAIMENT fait
ğŸ³ Docker = packaging

Docker transforme :

backend â†’ image

frontend â†’ image

DB â†’ image

ğŸ‘‰ Une image = application + runtime + dÃ©pendances

Pourquoi Docker ?

mÃªme comportement partout

plus de â€œÃ§a marche chez moiâ€

base de la CI/CD

ğŸ§© Docker Compose
frontend
backend
postgres


ğŸ‘‰ Sert Ã  :

lancer tout en local

tester rapidement

debug

ğŸ“Œ Docker Compose = CD locale simplifiÃ©e

5ï¸âƒ£ CI : GitHub Actions
Ce que fait la CI

Ã€ chaque push :

backend :

build Maven

tests

frontend :

npm install

build React

ğŸ‘‰ Si Ã§a passe :

le code est sain

prÃªt Ã  Ãªtre packagÃ©

ğŸ“Œ CI = vÃ©rifier, PAS dÃ©ployer

6ï¸âƒ£ Le GROS piÃ¨ge quâ€™on a eu (et pourquoi câ€™est un point fort)
âŒ ProblÃ¨me : backend qui ne dÃ©marre pas

Erreur :

no main manifest attribute

Pourquoi ?

Maven gÃ©nÃ©rait un JAR

MAIS pas un JAR exÃ©cutable

Docker faisait java -jar

Java ne trouvait pas le point dâ€™entrÃ©e

âœ… Solution

Configurer correctement :

spring-boot-maven-plugin
â†’ repackage


ğŸ‘‰ RÃ©sultat :

JAR Spring Boot exÃ©cutable

Docker OK

backend dÃ©marre

ğŸ“Œ Point trÃ¨s fort Ã  lâ€™oral : incident rÃ©el + rÃ©solution.

7ï¸âƒ£ Kubernetes (Minikube) : la CD
Pourquoi Kubernetes ?

standard entreprise

orchestration

gestion rÃ©seau

redÃ©marrage automatique

ğŸ‘‰ CESI demande une logique dâ€™hÃ©bergement, pas juste du local.

Namespace
projet-indiv


ğŸ‘‰ Sert Ã  :

isoler lâ€™application

Ã©viter les conflits

structuration pro

Services

backend-svc

frontend-svc

postgres-svc

ğŸ‘‰ Kubernetes ne parle PAS aux pods directement, mais aux services.

ProblÃ¨me rÃ©seau frontend â†’ backend

Erreur :

host not found in upstream "backend"

Pourquoi ?

Nginx pointait vers backend

En Kubernetes, le nom DNS = nom du service

Solution
proxy_pass http://backend-svc:80;


ğŸ“Œ LÃ  tu as compris :

DNS Kubernetes

service discovery

8ï¸âƒ£ Images & ErrImagePull
ProblÃ¨me
ErrImagePull

Pourquoi ?

Kubernetes cherchait une image inexistante

projet-indiv:0.0.1 â‰  images rÃ©ellement buildÃ©es

Solution

supprimer le deploy inutile (api)

utiliser les bonnes images

imagePullPolicy: IfNotPresent

9ï¸âƒ£ SÃ©curitÃ© API (auth demandÃ©e)
Pourquoi lâ€™API demandait un login ?

Spring Security activÃ©

endpoints protÃ©gÃ©s

Solution

Ajouter :

app.security.users:
  - admin / admin


ğŸ‘‰ SÃ©curitÃ© simple, claire, dÃ©montrable.

ğŸ” RÃ©sumÃ© des PROBLÃˆMES & SOLUTIONS (table mentale)
ProblÃ¨me	Cause	Solution
mvn not found	Java/Maven non installÃ©s	Installation + PATH
Docker ne dÃ©marre pas	mauvais engine	Docker Desktop Linux
backend crash	JAR non exÃ©cutable	repackage
frontend crash	mauvais DNS	backend-svc
ErrImagePull	image inexistante	nettoyer deploy
namespace not found	non crÃ©Ã©	create namespace
API protÃ©gÃ©e	security active	admin/admin
ğŸ¤ Ce que tu dois retenir pour lâ€™oral

Tu nâ€™as PAS â€œjuste suiviâ€ :

tu as mis en place une chaÃ®ne complÃ¨te

tu as rÃ©solu de vrais incidents

tu comprends maintenant chaque couche

ğŸ‘‰ Tu peux dÃ©fendre :

CI

Docker

Kubernetes

SÃ©curitÃ©

Architecture

Debug


Ce qui Ã©tait dÃ©jÃ  couvert (le cÅ“ur du projet)

Tout Ã§a, on lâ€™a bien fait et bien expliquÃ© :

Git + GitHub (repo, branches)

Backend Spring Boot (JPA, Flyway, Security)

Frontend React + Nginx

Docker (images, Dockerfile)

Docker Compose (CD locale)

CI GitHub Actions

Kubernetes / Minikube (CD orchestrÃ©e)

Namespace Kubernetes

Services, DNS, port-forward

SÃ©curitÃ© API

Debug rÃ©el (logs, ErrImagePull, CrashLoop, manifest, etc.)

ğŸ‘‰ Ã‡a suffit dÃ©jÃ  Ã  valider le bloc, clairement.

ğŸ” Les points que jâ€™ajoute pour Ãªtre exhaustif (et rassurant)
1ï¸âƒ£ Git & organisation du code (important CESI)

On lâ€™a fait, mais je le formalise :

Branches

main â†’ branche stable

develop â†’ travail courant

ğŸ‘‰ Ã‡a montre :

gestion propre du code

logique dâ€™intÃ©gration continue

Phrase oral :

Le dÃ©veloppement est rÃ©alisÃ© sur une branche dÃ©diÃ©e afin de sÃ©curiser la branche principale.

2ï¸âƒ£ GitHub Actions : mÃ©triques qualitÃ© implicites

On nâ€™a pas â€œnommÃ©â€ Ã§a comme tel, mais câ€™est bien lÃ  :

build Maven

tests backend

build frontend

ğŸ‘‰ Tu peux rattacher Ã§a Ã  :

qualitÃ©

fiabilitÃ©

prÃ©vention de dette technique

Si on te demande :

Comment tu mesures la qualitÃ© ?

Tu rÃ©ponds :

Via lâ€™automatisation des builds et tests en CI. Un build cassÃ© empÃªche toute livraison.

3ï¸âƒ£ JaCoCo (coverage)

MÃªme si on nâ€™a pas encore exploitÃ© le rapport :

JaCoCo est configurÃ©

prÃªt Ã  fournir une mÃ©trique de couverture

ğŸ‘‰ Tu peux dire :

La couverture de tests est mesurÃ©e via JaCoCo, ce qui permet dâ€™Ã©valuer la robustesse du code.

4ï¸âƒ£ Pourquoi un seul namespace

Tu lâ€™as volontairement choisi, et câ€™est dÃ©fendable.

Tu peux dire :

Pour un projet individuel et un pÃ©rimÃ¨tre limitÃ©, un seul namespace est suffisant et Ã©vite une complexitÃ© inutile.

ğŸ‘‰ TrÃ¨s bon point : simplicitÃ© maÃ®trisÃ©e.

5ï¸âƒ£ eval $(minikube docker-env) (dÃ©tail important)

On lâ€™a utilisÃ©, mais maintenant tu le comprends :

Ã§a connecte Docker au daemon Minikube

permet Ã  Kubernetes de voir les images locales

Phrase oral :

Les images Docker sont construites directement dans lâ€™environnement Minikube afin dâ€™Ã©viter un registry externe.

6ï¸âƒ£ port-forward (accÃ¨s aux services)

Tu lâ€™as fait, et câ€™est clÃ© :

Kubernetes nâ€™expose rien par dÃ©faut

port-forward = accÃ¨s contrÃ´lÃ©

ğŸ‘‰ Montre que tu comprends la sÃ©curitÃ© par dÃ©faut de Kubernetes.

7ï¸âƒ£ Kubernetes Dashboard

Tu sais maintenant :

minikube dashboard


ğŸ‘‰ Super pour montrer :

pods

services

Ã©tat du cluster


Ce que Ã§a change dâ€™avoir une VM Azure (crÃ©dit 100$)

Si tu me lâ€™avais dit dÃ¨s le dÃ©but :

On aurait pu hÃ©berger Jenkins + lâ€™app directement sur la VM dÃ¨s la phase Docker/CI, au lieu de tout faire â€œlocal onlyâ€.

On aurait pensÃ© plus tÃ´t Ã  : DNS/HTTPS, ports, firewall, logs, sauvegarde DB, et pipeline CD (push image â†’ pull sur VM).

Changer maintenant est malin, parce que :

Tu as dÃ©jÃ  un projet dockerisÃ© + k8s local (Minikube) â†’ on va juste ajouter une cible â€œVMâ€ (docker compose sur VM), et Jenkins par-dessus.

Le jury verra : CI (GitHub Actions) + CI (Jenkins) + dÃ©ploiement VM + (plus tard) CD k8s Minikube.

CÃ´tÃ© rÃ¨gles/limites Azure for Students : tu as bien un crÃ©dit 100$ et des limites de quota possibles.
Pour rester dans le budget : on choisit une petite VM burstable (sÃ©rie B) et on Ã©teint quand tu ne lâ€™utilises pas.

2) SÃ©curitÃ© demandÃ©e (JWT, hash, pas de mot de passe en clair, rate limitâ€¦)

Tu as raison : câ€™est exactement le genre de points qui font â€œTech Leadâ€.

On va mettre :

Inscription + Connexion (dÃ©mo obligatoire)

Mots de passe hashÃ©s BCrypt en base (jamais en clair)

JWT Bearer (API stateless)

Rate limit sur /api/auth/* : 20 requÃªtes / minute / IP (anti brute-force)

Bonus â€œproâ€ : sÃ©paration endpoints publics/privÃ©s, erreurs propres, et headers de sÃ©cu.

3) Front plus â€œvrai site e-commerceâ€

Oui : on passe dâ€™un front â€œminimalâ€ Ã  un front type shop :

Navbar (Catalogue / Mes commandes / Swagger)

Pages : Catalogue, Panier, Connexion, Inscription, Mes commandes (protÃ©gÃ©e)

Appels API rÃ©els, stockage JWT en localStorage, routes protÃ©gÃ©es

âœ… Nouveau ZIP prÃªt (Back JWT + Front plus beau + Rate limit + CI fix)

Je tâ€™ai prÃ©parÃ© une nouvelle version complÃ¨te du projet avec tout Ã§a intÃ©grÃ© :

Download Projet-Indiv-JWT-UI.zip

Ce que contient ce zip

Backend (Spring Boot) :

/api/auth/register + /api/auth/login (JWT)

table app_users (Flyway)

BCrypt

Rate limit Bucket4j (20/min/IP sur auth)

SecurityConfig stateless + filtre JWT

Frontend (React/Vite) :

pages Login/Register/Orders

UI plus â€œsiteâ€

Checkout qui crÃ©e une commande (si connectÃ©)

Docker :

docker-compose OK (db + backend + frontend)

Kubernetes Minikube :

manifests mis Ã  jour (env nginx + secret JWT)

GitHub Actions :

fix du job front : plus de package-lock obligatoire (Ã§a rÃ©glait ton erreur de cache)